---
title: "Sanitizing at the Poles"
date: 2018-01-01
draft: true
description: "Stop writing defensive code. There is a better way"
---

How often do you see ugly code like this? Or is this your code?

```
if( foo && foo.bar && foo.bar.baz ){
    console.log( foo.bar.baz );
}
```

Do you have a lot of defensive checks in your code to avoid runtime errors? What if you can avoid the defensive code all together with better choices earlier in your code? When I review code with others and I see heavily defensive code, I realize the developer has not taken the time to `Sanitize at the Poles`. There is a lot of unnecessary code that gets generated by the unknown factors. Let's use the following example as a case study.

```
public class BankAccount {
    private List<Transaction> transactions;

    public List<Transaction> getTransactions(){
        returns transactions;
    }

    public void setTransactions( List<Transaction> transactions){
        this.transactions = transactions;
    }
}
``` 

This is a simple enough Java class that can be quick to generate and not think about too much. It may not be obvious what is wrong at quick glance. But let's use this class and find out the problem

```
public class BankBusinessLogic {
    
    public double calculateBankAccountBalance( BankAccount bankAccount ){
        return bankAccount.getTransactions()
            .stream()
            .mapToDouble(Transaction::getAmount)
            .sum()
    }
}
``` 

In the above example, a call to `calculateBankAccountBalance()` before setting the list of transactions on the `BankAccount` object will result in a null pointer exception. Many developers without thinking will do the following

```
public class TransactionReportGenerator {
    public double calculateBankAccountBalance( BankAccount bankAccount ){
        if( bankAccount.getTransactions() == null ){
            return 0.00;
        } 

        return bankAccount.getTransactions()
            .stream()
            .mapToDouble(Transaction::getAmount)
            .sum()
    }
}
```

Adding the gated check here will work fine. It will do exactly what you want. But every time you want to use the transaction list from the bank account you have to perform a defensive check to make sure transactions is not null. Flip your thinking for a moment. Instead of checking for null at the point of use, protect against null at the point of creation. Looking back at the original `BankAccount` object can lead to a few better design choices

```
public class BankAccount {
    private List<Transaction> transactions = new ArrayList<Transaction>();

    public List<Transaction> getTransactions(){
        returns transactions;
    }

    public void setTransactions( List<Transaction> transactions){
        if( transactions == null ){
            this.transactions = new ArrayList<Transaction>();
        }else {
            this.transactions = transactions;
        }
    }
}
```

What we did here was ensure we have a better default value. Null is a very dangerous value and making a better choice on the default value protects you. The 2nd thing to do is protect against bad values in the setters. Control what users are allowed to set. Sanitize at the point of the input. Now there is no need to have the null defensive checks everywhere that this code is used. 

## Interesting, Tell me More 
Let's look at this from a different angle with an MVC Application. When the MVC pattern emerges in my designs, I take a moment to reflect on where my poles are and code accordingly. The MVC model looks like the following
{{< figure src="/img/mvc.png" title="Simple example of an MVC application" >}}

Looking at the diagram you can see the single point of direction is to the model. The model is your record keeping system. It makes sense to make sure that the data in your records is correct. So use the model as your single place of sanitation.

Looking at different sources of data you could come up with the following.

  * Data from rest service - sanitized by the Model
  * Data from a database - sanitized by the Model
  * User Entered Data - input may be verified by View but Sanitized by Model

{{< figure src="/img/mvc_annotate.png" title="Data Source and User Input sanitation" >}}

But you may be thinking, I have created a rest service and user data is passed into my controller, my controller is sanitizing the input. Well no, with most frameworks you have automatic model binding (see Spring) or you are violating separation of concerns and/or single responsibility. If you are using a framework that does not have model binding of objects, create a new model based on the user input and sanitize there. Keep things simple,  

{{< figure src="/img/mvc_poles.png" title="Data from all 3 poles is sanitized at the model" >}}

Now that the 3 poles are passing down to the model, we hve our single point of sanitation. There is no more need to be defensive in the Controller or Service layers as it can trust the contracts that the model provides. Now your Business logic can focus on business logic, and not data contracts. The view can more confidently display data without worrying about throwing "undefined" or "null" on the output.

Sanitization in the models will create a lot less code for you. There are no more of the "what if" scenarios because you have a good contract in your objects.

When teaching this to others I commonly flatten the diagram and display it with a simplification. I feel this sums things up nicely and easier to write out.
```
| stdIn - ( controller - view - model ) - stdOut | 
```

## Last Thoughts.
A recent proposal in the Javascript world troubles me a bit. With the addition of a [Null-conditional Operator](https://github.com/tc39/proposal-optional-chaining) you will have another way for developers to try and protect themselves from themselves. Instead of taking the time to sanitize in one spot properly, you are going to see this littered all over the code. This is going to make things un-readable in some code bases. Looking at this `if( foo?.bar?.baz?.baq)` makes me a bit sick. You just know this is going to be abused. I never liked it in C#, and I don't like it here.

Sure the proposal is much better than `foo && foo.bar && foo.bar.baz && foo.bar.baz.baq`, but I would like to get to a place where neither is necessary. Make developers choose better defaults and try and avoid null the best they can in their contracts. We as developers need less tools and more discipline.